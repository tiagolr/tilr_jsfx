desc:Rippler
author: tilr
version: 1.0.0
changelog:
  First
about:
  # Rippler - a physical modeled synth
tags: synth, instrument

<? npartials < 1 ? npartials = 32 ?>
<? npolyphony < 1 ? npolyphony = 8 ?>
config: npartials "Partials" 32 4 16 32 64
config: npolyphony "Polyphony" 8 4 8 12 16

options:gfx_hz=60

import rippler.array.jsfx-inc
import rippler.modal.jsfx-inc
import rippler.rbj_filter.jsfx-inc

slider1:/tilr8_Rippler:none:Click
slider2:click_mix=0<0,100,.01>Mallet Mix
slider3:click_res=80<0,100,.01>Mallet Resonance
slider4:click_pitch=0<-24,24,1>Pitch
slider5:click_ktrack=0<0,1,1{No, Yes}>KeyTrack
slider6:click_filter_mode=0<0,2,1{LP,BP,HP}>Mallet Filter Mode
slider7:click_filter_freq=20000<20,20000,1:log>Mallet Filter Freq

slider10:model=0<0,6,1{String,Beam,Metal,Membrane,Plate,Drumhead,Marimba}>Model
slider11:decay=1<0.01,100,0.01:log>Decay
slider12:freq_damp=0<-100,100,0.1>Material
slider13:tone=0<-100,100,0.1>Tone
slider14:hit_position=26<2,50,0.1>Hit Position
slider15:release=100<0,100,0.1>Release
slider16:inharmonic=0.01<0.01,100,0.001:log>Inharmonic
slider17:ratio=1<0.1,10,0.01:log>Ratio
slider18:lowcut=20<20,20000,1:log>Low Cut

@init
ext_noinit = 1;
<? printf("npartials = %d;\n", npartials); ?>
<? printf("npolyphony = %d;\n", npolyphony); ?>
lfile = -1;
lmodel = model;
wavechn = 0;
wavesrate = 0;
wavelen = 0;
base_note = 60;
playback_speed = 1;
nstring = 0;
freemem = 100000;
freemem = init_models(freemem);

models = freemem; freemem += 7;
models[0] = string;
models[1] = beam;
models[2] = metal;
models[3] = membrane;
models[4] = plate;
models[5] = drumhead;
models[6] = marimba;

freemem = poly.array_init(freemem, 10, 7); // [note, velocity, freq, playback_speed, nstring, release]
freemem = midi.array_init(freemem, 256, 4); // [offset, status, note, vel]
clickl = freemem; freemem += 500000; // click left channel buffer
clickr = freemem; freemem += 500000; // click right channel buffer
wavebuf = freemem; // file reader buffer

function db2gain (db) local (val) (
  val = 10^(db / 20);
  val <= 0.001 ? 0 : val;
);
function rc_set(rc)
instance(a) (
  a = 1 / (rc * srate + 1);
);
function rc_lp(sample)
instance(lp, a) (
  lp += a * (sample - lp);
);
function smooth()
instance (lp, smooth) (
  lp = smooth;
  smooth = this.rc_lp(this);
);

function normalize_vol_slider(val) ( val * 75 / 100 - 60 );
function note2freq(n) ( 440 * pow(2, (n - 69) / 12); );

function read_file(filehandle)
local(i)
(
  filehandle > 0 ? (
    file_riff(filehandle, wavechn, wavesrate);
    wavechn ? (
      wavelen = file_avail(filehandle);
      file_mem(filehandle,wavebuf, min(wavelen, 500000));
    );
    file_close(filehandle);
    wavechn == 2 ? (
      wavelen = (wavelen / 2) | 0;
      i = 0; loop(wavelen,
        clickl[i] = wavebuf[i*2];
        clickr[i] = wavebuf[i*2+1];
        i += 1;
      );
    ) : (
      memcpy(clickl,wavebuf,wavelen);
      memcpy(clickr,wavebuf,wavelen);
    );
  );
);

function on_file_change() (
  lfile = slider1;
  filehandle=file_open(slider1);
  read_file(filehandle);
);

function on_slider()
(
  lmodel != model ? (
    ratio = model == 1 ? 2 : 0.78;
    <?
      loop(i=1;npolyphony,
        printf("s%02d.string_clear();\n", i);
        i+=1;
      );
    ?>
  );
  lmodel = model;
  model == 1 ? recalc_beam();
  model == 3 ? recalc_membrane();
  model == 4 ? recalc_plate();

  lfile != slider1 ? on_file_change();
  inharm = inharmonic == 0.01 ? 0 : inharmonic / 100;
  playback_speed = 2^((click_pitch / 12) | 0);
  lowcut_filter.rbj_hp(lowcut, 0.707);
  click_filter_mode == 0 ? (
    <?
      loop(i=1;npolyphony,
        printf("click_filter_l%02d.rbj_lp(click_filter_freq, 0.707);\n",i);
        printf("click_filter_r%02d.rbj_lp(click_filter_freq, 0.707);\n",i);
        i+=1;
      );
    ?>
  );
  click_filter_mode == 1 ? (
    <?
      loop(i=1;npolyphony,
        printf("click_filter_l%02d.rbj_bp(click_filter_freq, 0.707);\n",i);
        printf("click_filter_r%02d.rbj_bp(click_filter_freq, 0.707);\n",i);
        i+=1;
      );
    ?>
  );
  click_filter_mode == 2 ? (
    <?
      loop(i=1;npolyphony,
        printf("click_filter_l%02d.rbj_hp(click_filter_freq, 0.707);\n",i);
        printf("click_filter_r%02d.rbj_hp(click_filter_freq, 0.707);\n",i);
        i+=1;
      );
    ?>
  );

  <?
    loop(i=1;npolyphony,
      printf("s%02d.string_init(s%02d.f0, s%02d.rel);\n", i, i);
      i += 1;
    );
  ?>
);

@slider

rel_pos = min(max(0.01, position / 100), 0.99);

on_slider();

@block
// remove queued midi messages that have been processed
ptr = midi.array_first();
while (ptr >= 0) (
  ptr[0] < 0 ? (
    midi.array_remove(ptr);
    ptr = midi.array_first();
  ) : (
    ptr = midi.array_next(ptr);
  );
);

while (midirecv(offset, msg1, note, vel)) (
  event = msg1 & 0xF0;
  channel = msg1 & 0x0F;

  // note on/off
  event == 0x90 || event == 0x80 ? (
    // prevent midi buffer overflow
    midi.size == 256 ? (
      midi.array_remove(midi.array_first());
    );
    ptr = midi.array_add();
    ptr[0] = offset;
    ptr[1] = msg1;
    ptr[2] = note;
    ptr[3] = vel;
  );

  // All notes off
  event == 0xB0 && note == 123 ? (
    poly.array_clear();
    //hold.array_clear();
  );

  midisend(offset, msg1, note, vel);
);

@sample
function on_note(p)
local (ptr, note_repeat, note, vel, env, freq)
(
  note = p[2];
  vel = p[3];

  // remove note if it is already playing
  ptr = poly.array_find(note);
  ptr >= 0 ? poly.array_remove(ptr);

  freq = note2freq(note);
  ptr = poly.array_add();
  ptr[0] = note;
  ptr[1] = vel / 127;
  ptr[2] = freq / srate;
  ptr[3] = 0;
  ptr[4] = 2 ^ ((note - base_note) / 12);
  ptr[5] = nstring;
  ptr[6] = 0; // note release

  <?
    loop(i=1;npolyphony,
      printf("nstring == %d ? s%02d.string_init(freq, 0);\n", i-1, i);
      printf("nstring == %d ? (s%02d.active = 1; s%02d.silence = 0);\n", i-1, i, i);
      i += 1;
    );
  ?>

  nstring = (nstring + 1) % npolyphony;
);

function off_note(p)
local(ptr, note, pp, freq)
(
  note = p[2];
  ptr = poly.array_find(note);
  ptr >= 0 ? (
    <?
      loop(i=1;npolyphony,
        printf("ptr[5] == %d ? s%02d.string_init(s%02d.f0, 1);\n", i-1, i, i);
        i += 1;
      );
    ?>
    ptr[6] = 1;
  );
);

function handle_midi(p)
local(msg1, vel, event)
(
  msg1 = p[1];
  vel = p[3];
  event = msg1 & 0xF0;
  event == 0x90 && vel ? on_note(p); // Note on
  event == 0x80 || (event == 0x90 && !vel) ? off_note(p); // Note off
);

/**
  Sample linear interpolation
*/
function wave_lerp(buf, pos)
local(x, i, j)
(
  i = pos|0;
  x = pos - i;
  j = i + 1;
  j >= wavelen ? j = 0;
  (1 - x) * buf[i] + x * buf[j];
);

// process queued midi
ptr = midi.array_first();
while(ptr >= 0) (
  ptr[0] == 0 ? ( // offset has reached zero
    handle_midi(ptr);
  );
  ptr[0] -= 1;
  ptr = midi.array_next(ptr);
);

// process notes being played
ptr = poly.array_first();
<?
  loop(i=1;npolyphony,
    printf("outc_%02d = 0;\n",i);
    i+=1;
  );
?>
malletl = 0;
malletr = 0;
splmono = (spl1 + spl2) / 2;
while(ptr >= 0) ( // for each note/voice
  ptr[3] >= 0 ? ( // if note is playing sample
    outl = wave_lerp(clickl, ptr[3]);
    outr = wave_lerp(clickr, ptr[3]);
    
    click_filter_mode == 1 || 
    (click_filter_mode == 2 && click_filter_freq > 20) ||
    (click_filter_mode == 0 && click_filter_freq < 20000)  
    ? (
      <?
        loop(i=1;npolyphony,
          printf("ptr[5] == %d ? (\n", i - 1);
          printf("  outl = click_filter_l%02d.rbj_df1(outl);\n",i);
          printf("  outr = click_filter_r%02d.rbj_df1(outr);\n",i);
          printf(");\n");
          i+=1;
        );
      ?>
    );
    
    malletl += outl;
    malletr += outr;
    ptr[3] += click_ktrack // samplepos += playback_speed
      ? ptr[4] * playback_speed
      : playback_speed;
    ptr[3] >= wavelen ? ptr[3] = -1; // finished sample playback
    <?
      loop(i=1;npolyphony,
        printf("ptr[5] == %d ? outc_%02d = (outl + outr) / 2 * click_res / 100;\n",i-1, i);
        i+=1;
      );
    ?>
  );
  ptr = poly.array_next(ptr);
);

out_res = 0;

<?
  loop(i=1;npolyphony,
    printf("out_res += s%02d.string_process(splmono + outc_%02d);\n", i, i);
    i += 1;
  );
?>

lowcut > 20 ? (
  out_res = lowcut_filter.rbj_df1(out_res);
);

spl0 = malletl * click_mix / 100 + out_res;
spl1 = malletr * click_mix / 100 + out_res;

// remove notes that finish playing and are no longer pressed
ptr = poly.array_first();
while (ptr >= 0) (
  ptr[3] == -1 && ptr[6] ? (
    poly.array_remove(ptr);
    ptr = poly.array_first();
  ) : (
    ptr = poly.array_next(ptr);
  );
);






