desc:MIDI Repeater
author: tilr
version: 1.0.0
about: MIDI note repeater used for hat or snare rolls.
       Starting from C (1 bar) each note repeats at a different tempo
       White keys on the piano repeat in straight notes
       Black keys on the piano repeat in tripplets

slider1:note_out=60<0, 127, 1>Note out
slider2:_time_mult=0<-1, 1, 0.01>Time mult
slider3:gate=1<0,1,0.01>Gate %

in_pin:none;
out_pin:none;

@init
ext_noinit= 1;

function array_init(index, max_rows, cols)
  instance(buf, size, num)
(
  buf = index;
  size = 0;
  num = cols;

  buf + max_rows * num;
);

function array_init(index, max_rows)
(
  this.array_init(index, max_rows, 1);
);

function array_get(row)
  instance(buf, num)
(
  buf + row * num;
);

function array_add()
  instance(buf, size, num)
(
  buf + ((size += 1) - 1) * num;
);

function array_insert(ptr)
  instance(buf, size, num)
  local(end)
(
  end = buf + size * num;
  size += 1;
  ptr < end ? memcpy(ptr + num, ptr, end - ptr);

  // Returning the pointer here might not be very useful, but it is
  // consistent with array_add().
  ptr;
);

function array_remove(ptr)
  instance(buf, size, num)
  local(end)
(
  end = buf + (size -= 1) * num;
  ptr < end ? memcpy(ptr, ptr + num, end - ptr);

  // Again, returning the pointer here is not very useful; meh.
  ptr;
);

function array_first()
  instance(buf, size)
(
  size ? buf : -1;
);

function array_next(ptr)
  instance(buf, size, num)
(
  ptr += num;
  ptr < buf + size * num ? ptr : -1;
);

function array_last()
  instance(buf, size, num)
(
  size ? buf + (size - 1) * num : -1;
);

function array_find(value, col, ptr)
  instance(buf, size, num)
  local(ret, end)
(
  ret = -1;
  end = buf + size * num;
  while(
    ptr < end ? (
      ptr[col] == value ? (
        ret = ptr;
        0; // break
      ) : (
        ptr += num;
        1; // continue
      );
    );
  );
  ret;
);

function array_find(value, col)
  instance(buf)
(
  this.array_find(value, col, buf);
);

function array_find(value)
  instance(buf, size, num)
  local(ret, ptr, end)
(
  ret = -1;
  end = (ptr = buf) + size * num;
  while(
    ptr < end ? (
      ptr[] == value ? (
        ret = ptr;
        0; // break
      ) : (
        ptr += num;
        1; // continue
      );
    );
  );
  ret;
);

function array_clear()
  instance(size)
(
  size = 0;
);

function samples_to_next_beat()
(
  phase = beat_pos * samples_per_beat;
  rem = samples_per_beat - (phase % samples_per_beat);
  rem == samples_per_beat ? rem = 0;

  rem;
);

function schedule_noteon()
(
  noteon_countdown = samples_to_next_beat();
);

function schedule_noteoff()
(
  noteoff_countdown = max(samples_to_next_beat(), 1);
);

// ==============================

noteon_countdown = -1;
noteoff_countdown = -1;
notes_stack.array_init(1000, 128, 3);

@slider


@block
NOTE_ON = $x90;
NOTE_OFF = $x80;

block_offset = 0;
playing = play_state & 1;
samples_per_beat = srate * 60 / tempo;
beats_per_sample = tempo / (60 * srate);
playing ? beat_pos = beat_position;

while
(
  midirecv(offset,msg1,note,vel) ?
  (
    status = msg1 & $xF0;
    channel = msg1 & $x0F;

    status == NOTE_ON && vel > 0 ?
    (
      ptr = notes_stack.array_find(note);
      ptr > -1 ? notes_stack.array_remove(ptr);
      ptr = notes_stack.array_add();
      ptr[0] = note;
      ptr[1] = vel;
      ptr[2] = channel;

      notes_stack.size == 1 ? schedule_noteon();
    )
    : status == NOTE_OFF || (status == NOTE_ON && vel == 0) ?
    (
      ptr = notes_stack.array_find(note);
      ptr > -1 ? notes_stack.array_remove(ptr);
    )
    :
    (
      midisend(offset, msg1, note, vel);
    );
    1; // Force loop to continue until all messages have been processed
  );
);

@sample

ptr = notes_stack.array_last();
ptr > -1 ? (
  _note = ptr[0];
  _vel = ptr[1];
  _channel = ptr[2];
);

// note OFF
noteoff_countdown == 0 ? (
  midisend(block_offset, 0x80 + _channel, _note, _vel);
  notes_stack.size 
    ? schedule_noteon();
);

// note ON
noteon_countdown == 0 ? (
  notes_stack.size ? (
    midisend(block_offset, 0x90 + _channel, _note, _vel);
    schedule_noteoff();
  )
);


block_offset += 1;
beat_pos += beats_per_sample;
noteon_countdown -= 1;
noteoff_countdown -= 1;
