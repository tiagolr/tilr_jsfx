desc: Albeton - Autopan
author: tilr
version: 1.0.0

slider1:_amount=0.5<0.0,1,0.01>Amount
slider2:_rate=1<0.01,5000,0.01:log>Rate (Hz)
slider3:_rate_sync=0<0,24,1{Off,1/64,1/32,1/16,1/8,1/4,1/2,1/1,2/1,3/1,4/1,1/64T,1/32T,1/16T,1/8T,1/4T,1/2T,1/1T,1/64D,1/32D,1/16D,1/8D,1/4D,1/2D,1/1D}>Rate Sync
slider4:_offset=90<0,360,1>Offset
slider5:_phase=180<0,360,1>Phase
slider6:_spin=0<-1,1,0.01>Spin
slider7:_shape=0<1,50,0.1:log>Shape
slider8:_wave=0<0,3,1{Sine,Tri,Saw,Rand}>Waveform
slider9:_use_spin=0<0,1,1{False,True}>-Use Spin
slider10:_invert=0<0,1,1{False,True}>-Invert

@init
israte = 1/srate;
play_pos = play_position;
salpha = exp(-2.0 * $pi * 200 / srate);
l.seed = floor(rand(1000000) + 10);
r.seed = floor(rand(1000000) + 10);
l.randphase = l.seed;
r.randphase = r.seed;

function sine(phase) (cos(2*$pi*phase));
function triangle(phase)
(
    4*abs(phase - 0.5) - 1
);
function saw(phase) (1 - 2 * phase);
function tanh(x) (
  x = exp(2*x);
  (x - 1) / (x + 1)
);
function rand_wave()
instance(randphase, prev_cycle, prev_val)
local(val, cycle)
(
  cycle = floor(randphase);
  val = cycle != prev_cycle
    ? rand() * 2 - 1
    : prev_val;
  prev_cycle = cycle;
  prev_val = val;
  val
);
function wave(phase, is_right)
local(val)
(
  val = _wave == 0 ? sine(phase) :
        _wave == 1 ? triangle(phase) :
        _wave == 2 ? saw(phase) :
        _wave == 3 && is_right ? r.rand_wave() :
        _wave == 3 && !is_right ? l.rand_wave();

  _shape > 1 ? tanh(val*_shape) : val
);
function normalize(val) ( val * 0.5 + 0.5 );

function get_sync_qn()
global(_rate_sync)
local(t)
(
  t =
    _rate_sync == 0  ? 1.0  : // Off
    _rate_sync == 1  ? 0.0625 : // 1/64
    _rate_sync == 2  ? 0.125   : // 1/32
    _rate_sync == 3  ? 0.25    : // 1/16
    _rate_sync == 4  ? 0.5     : // 1/8
    _rate_sync == 5  ? 1.0     : // 1/4
    _rate_sync == 6  ? 2.0     : // 1/2
    _rate_sync == 7  ? 4.0     : // 1/1
    _rate_sync == 8  ? 8.0     : // 2/1
    _rate_sync == 9  ? 12.0    : // 3/1
    _rate_sync == 10 ? 16.0    : // 4/1
    _rate_sync == 11 ? 0.0625 * 2/3 : // 1/64T
    _rate_sync == 12 ? 0.125  * 2/3 : // 1/32T
    _rate_sync == 13 ? 0.25   * 2/3 : // 1/16T
    _rate_sync == 14 ? 0.5    * 2/3 : // 1/8T
    _rate_sync == 15 ? 1.0    * 2/3 : // 1/4T
    _rate_sync == 16 ? 2.0    * 2/3 : // 1/2T
    _rate_sync == 17 ? 4.0    * 2/3 : // 1/1T
    _rate_sync == 18 ? 0.0625 * 1.5 : // 1/64D
    _rate_sync == 19 ? 0.125  * 1.5 : // 1/32D
    _rate_sync == 20 ? 0.25   * 1.5 : // 1/16D
    _rate_sync == 21 ? 0.5    * 1.5 : // 1/8D
    _rate_sync == 22 ? 1.0    * 1.5 : // 1/4D
    _rate_sync == 23 ? 2.0    * 1.5 : // 1/2D
    _rate_sync == 24 ? 4.0    * 1.5 : // 1/1D
    1.0;

  t;
);

function on_slider()
(
  sync_qn = get_sync_qn();
  sync_qnl = sync_qn;
  sync_qnr = sync_qn;
  _use_spin ? sync_qnr *= 0.25 * pow(16, (_spin + 1) * 0.5);

  offsetl = _offset / 360;
  offsetr = _offset / 360 + (_use_spin ? 0 : _phase / 360);
  slider_show(_phase, !_use_spin);
  slider_show(_spin, _use_spin);
);

@slider

on_slider();

@block
beats_per_spl = _rate_sync > 0
  ? tempo / (60 * srate)
  : israte * _rate;
play_state & 1 && _rate_sync > 0 ? (
  beat_pos = beat_position;
);

@sample

lwave = normalize(wave(lphase, 0));
rwave = normalize(wave(rphase, 1));

_invert ? (
  lwave = 1 - lwave;
  rwave = 1 - rwave;
);

lsmooth = prevlsmooth*salpha + lwave*(1-salpha);
prevlsmooth = lsmooth;

rsmooth = prevrsmooth*salpha + rwave*(1-salpha);
prevrsmooth = rsmooth;

spl0 *= 1 + (lsmooth - 1) * _amount;
spl1 *= 1 + (rsmooth - 1) * _amount;

// update phase
lphase = beat_pos / sync_qnl + offsetl;
rphase = beat_pos / sync_qnr + offsetr;
lphase -= floor(lphase);
rphase -= floor(rphase);
// rand phase
l.randphase = l.seed + beat_pos / sync_qnl + offsetl;
r.randphase = r.seed + beat_pos / sync_qnr + offsetr;
//
beat_pos += beats_per_spl;

@gfx 500 140

color_bg = 0x111111;
color_active = 0xffff00;
winx = 0;
winy = 30;
winw = gfx_w;
winh = gfx_h-30;

function update_mouse_state()
instance(cap, x, y, lx, ly, dx, dy, right_click, left_click, lleft, lright, left, right, click_time, double_click, control, lwheel, wheel)
global(mouse_cap, mouse_x, mouse_y, mouse_wheel)
(
  lleft = left;
  lright = right;
  lx = x;
  ly = y;
  cap = mouse_cap;
  control = mouse_cap & 4;
  x = mouse_x;
  y = mouse_y;

  left = cap & 1 > 0;
  right = cap & 2 > 0;
  left_click = left && lleft == 0;
  right_click = right && lright == 0;
  dx = x - lx;
  dy = y - ly;
);

function set_color(color) (
  gfx_r = (color & 0xFF0000) / 0xFF0000;
  gfx_g = (color & 0x00FF00) / 0x00FF00;
  gfx_b = (color & 0x0000FF) / 0x0000FF;
);

function mouse_in_rect (x, y, w ,h) (
  mouse.x >= x && mouse.x <= x + w && mouse.y >= y && mouse.y <= y + h;
);

function point_in_rect (x1, y1, x, y, w, h) (
  x1 >= x && x1 <= x + w && y1 >= y && y1 <= y + h;
);

function gfx_wave(phase, is_right)
global(_shape, _invert, _wave)
local(val, r)
(
  val = _wave == 0 ? sine(phase) :
        _wave == 1 ? triangle(phase - floor(phase)) :
        _wave == 2 ? saw(phase - floor(phase));

  _wave == 3 ? (
    r = floor(phase) + 5000;
    is_right ? r += 10000;
    val = sin(r * 12.9898) * 43758.5453; // pseudo rand
    val = (val - floor(val)) * 2 - 1;
  );

  _shape > 1 ? val = tanh(val*_shape);
  _invert ? val *= -1;
  val;
);

function draw_button (x, y, w, label, toggled) (
  gfx_a = 1;
  set_color(color_active);
  gfx_rect(x, y - 2, w, 10 + 2, toggled);
  gfx_x = x; gfx_y = y;
  set_color(toggled ? color_bg : color_active);
  gfx_drawstr(label, 1, x+w, y+10);
);

function draw_waveform(rat, off, is_right)
global(_amount, gfx_w, gfx_h, gfx_x, gfx_y, winx, winy, winh, winw)
local(inc, x, y, phase)
(
  rat *= 2;
  rat < 1 ? rat = 1;
  x = 0;
  phase = off;
  inc = rat / winw;

  x = 0;
  gfx_x = x;
  gfx_y = winy + winh/2 + (winh/2 - 1) * gfx_wave(phase, is_right) * _amount;

  loop(gfx_w,
    y = winy + winh/2 + (winh/2 - 1) * gfx_wave(phase, is_right) * _amount;
    gfx_lineto(x, y);
    phase += inc;
    x += 1;
  );
);

gfx_clear = color_bg;
mouse.update_mouse_state();
set_color(0xffff00);

draw_waveform(_rate_sync > 0 ? tempo / (60 * sync_qnl) : _rate, offsetl, 0);
set_color(0x00ffff);
draw_waveform(_rate_sync > 0
  ? tempo / (60 * sync_qnr)
  : _use_spin ? _rate / (0.25 * pow(16, (_spin + 1) * 0.5))
  : _rate
,offsetr,1);

draw_button(10,10,60,"Invert",_invert);
draw_button(10 + 60 + 10,10, 60,"Spin",_use_spin);

mouse.left_click && mouse_in_rect(10,10,60,12) ? (
  _invert = !_invert;
);

mouse.left_click && mouse_in_rect(10+60+10,10,60,12) ? (
  _use_spin = !_use_spin;
  on_slider();
);
